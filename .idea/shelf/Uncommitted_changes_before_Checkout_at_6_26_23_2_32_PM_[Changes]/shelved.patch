Index: src/client.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <iostream>\n#include \"binfhecontext-ser.h\"\n#include \"encode.h\"\n#include \"data.h\"\n#include <future>\n#include <getopt.h>\n#include <stdlib.h>\n\nvoid help();\nint keygen();\nint encrypt(const char* dirName);\nint decrypt(const char* dirNname);\n\nint main(int argc , char* argv[])\n{\n\tint c = 0;\n\toption opt[] = \n\t{\n\t\t{\"help\" , 0 , NULL , 'h'} , \n\t\t{\"keygen\" , 0 , NULL , 'k'} , \n\t\t{\"name\" , 1 , NULL , 'n'} , \n\t\t{\"decrypt\" , 1 , NULL , 'd'} , \n        {\"encrypt\" , 1 , NULL , 'e'}\n\t};\n\twhile((c = getopt_long(argc , argv , \"hn:d:ke:\" , opt , NULL)) != -1)\n\t{\n\t\tswitch(c)\n\t\t{\n\t\t\tcase 'h':\n\t\t\t\thelp();\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tkeygen();\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\t// encrypt(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdecrypt(optarg);\n\t\t\t\tbreak;\n            case 'e':\n\t\t\t\tencrypt(optarg);\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tstd::cout << \"unknown argument.\\n\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstd::cout << \"unknown error.\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid help()\n{\n\tstd::cout << \"Usage: ./cleint [options] ...\\n\";\n\tstd::cout << \"Options:\\n\";\n\tstd::cout << \"\\t-h, --help\\t\\tdisplay this help and exit.\\n\";\n\tstd::cout << \"\\t-k, --keygen\\t\\tgenerate a key and save in \\\"./myKey\\\".\\n\";\n\tstd::cout << \"\\t-n, --name NAME\\t\\tgenerate a file that can query by NAME(at most 8 characters). It also generate a file for decryption named \\\"CC\\\".\\n\";\n\tstd::cout << \"\\t-d, --decrypt FILENAME\\tdecrypt the result which is named FILENAME by \\\"./myKey\\\" and show the result.\\n\";\n\treturn;\n}\n\nint keygen()\n{\n\tstd::cout << \"Start generating the key...\\n\";\n\tauto CryptoContext = lbcrypto::BinFHEContext();\n\tCryptoContext.GenerateBinFHEContext(lbcrypto::MEDIUM);\n\tauto SecretKey = CryptoContext.KeyGen();\n\tstd::cout << \"Start saving the key...\\n\";\n\tif(lbcrypto::Serial::SerializeToFile(std::string(\"myKey\") , SecretKey , lbcrypto::SerType::BINARY) == 0)\n\t{\n\t\tstd::cerr << \"Error saving key.\\n\";\n\t\treturn 1;\n\t}\n\tif(lbcrypto::Serial::SerializeToFile(std::string(\"CC\") , CryptoContext , lbcrypto::SerType::BINARY) == 0)\n\t{\n\t\tstd::cerr << \"Error saving CC.\\n\";\n\t\treturn 2;\n\t}\n\tstd::cout << \"Completed.\\n\";\n\treturn 0;\n}\n\nint encrypt(const char* dirName)\n{\n\tlbcrypto::LWEPrivateKey sk;\n\tlbcrypto::BinFHEContext cc;\n\tlbcrypto::Serial::DeserializeFromFile(\"myKey\" , sk , lbcrypto::SerType::BINARY);\n\tlbcrypto::Serial::DeserializeFromFile(\"CC\" , cc , lbcrypto::SerType::BINARY);\n\tstd::vector <data_> data;\n\tFILE* fptr = fopen(\"data.csv\" , \"r\");\n\tif(fptr == nullptr)\n\t{\n\t\tstd::cout << \"Error when open file \" << \"data.csv\" << \"\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i = 0 , c = 0 ; (c = fgetc(fptr)) != EOF ; i++)\n\t{\n\t\tdata_ temp;\n\t\tfor(int j = 0 ; j < 9 ; j++)\n\t\t{\n\t\t\ttemp.name[j] = 0;\n\t\t}\n\t\tfor(int j = 0 ; c != ',' ; j++)\n\t\t{\n\t\t\ttemp.name[j] = c;\n\t\t\tc = fgetc(fptr);\n\t\t}\n\t\tfscanf(fptr , \"%d,%d,%d\\n\" , &(temp.caseNum) , &(temp.location) , &(temp.time));\n\t\tdata.push_back(temp);\n\t}\n\n\tfclose(fptr);\n\n\t#if DEBUG\n\n\tfor(auto i = data.begin() ; i != data.end() ; i++)\n\t{\n\t\tstd::cout << i -> name << \"\\t\";\n\t\tstd::cout << i -> caseNum << \"  \";\n\t\tstd::cout << i -> location << \"\\t\";\n\t\tstd::cout << i -> time << \"\\n\";\n\t}\n\n\t#endif\n\n\tcc.BTKeyGen(sk);\n\tchar* temp;\n\tasprintf(&temp , \"mkdir %s\" , dirName);\n\tsystem(temp);\n\tasprintf(&temp , \"%s/length\" , dirName);\n\tfptr = fopen(temp , \"wb\");\n\tfprintf(fptr , \"%zu\" , data.size());\n\tfclose(fptr);\n\n\tint thread = 16;\n\tstd::vector <std::future <bool>> threads;\n\tint blockSize = (data.size() - 1) / thread + 1;\n\n\t#if DEBUG\n\n\tstd::cout << \"Data size : \" << data.size() << \"\\n\";\n\tstd::cout << \"Block size : \" << blockSize << \"\\n\";\n\n\t#endif\n\n\tfor(int i = 0 ; i < thread ; i++)\n\t{\n\t\tthreads.push_back(std::async([&](int i)\n\t\t{\n\t\t\tlbcrypto::LWECiphertext tempCipher;\n\t\t\tchar* filename = NULL;\n\t\t\tint decTime[13] = {0};\n\t\t\tint decCase[3] = {0};\n\t\t\tint decName[40] = {0};\n\t\t\tint decLocation[8] = {0};\n\t\t\tfor(int b = 0 ; b < blockSize ; b++)\n\t\t\t{\n\t\t\t\tif(b + i * blockSize >= data.size())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// std::cout << b + i * blockSize << \" \";\n\t\t\t\tdecodeName(data[b + i * blockSize].name , decName);\n\t\t\t\tfor(int j = 0 ; j < 40 ; j++)\n\t\t\t\t{\n\t\t\t\t\tasprintf(&filename , \"%s/%dN%02d\" , dirName , b + i * blockSize , j);\n\t\t\t\t\ttempCipher = cc.Encrypt(sk , decName[j]);\n\t\t\t\t\tlbcrypto::Serial::SerializeToFile(filename , tempCipher , lbcrypto::SerType::BINARY);\n\t\t\t\t}\n\t\t\t\tdecodeCase(data[b + i * blockSize].caseNum , decCase);\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++)\n\t\t\t\t{\n\t\t\t\t\tasprintf(&filename , \"%s/%dC%02d\" , dirName , b + i * blockSize , j);\n\t\t\t\t\ttempCipher = cc.Encrypt(sk , decCase[j]);\n\t\t\t\t\tlbcrypto::Serial::SerializeToFile(filename , tempCipher , lbcrypto::SerType::BINARY);\n\t\t\t\t}\n\t\t\t\tdecodeTime(data[b + i * blockSize].time , decTime);\n\t\t\t\tfor(int j = 0 ; j < 13 ; j++)\n\t\t\t\t{\n\t\t\t\t\tasprintf(&filename , \"%s/%dT%02d\" , dirName , b + i * blockSize , j);\n\t\t\t\t\ttempCipher = cc.Encrypt(sk , decTime[j]);\n\t\t\t\t\tlbcrypto::Serial::SerializeToFile(filename , tempCipher , lbcrypto::SerType::BINARY);\n\t\t\t\t}\n\t\t\t\tdecodeLocation(data[b + i * blockSize].location , decLocation);\n\t\t\t\tfor(int j = 0 ; j < 8 ; j++)\n\t\t\t\t{\n\t\t\t\t\tasprintf(&filename , \"%s/%dL%02d\" , dirName , b + i * blockSize , j);\n\t\t\t\t\ttempCipher = cc.Encrypt(sk , decLocation[j]);\n\t\t\t\t\tlbcrypto::Serial::SerializeToFile(filename , tempCipher , lbcrypto::SerType::BINARY);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} , i));\t\t\n\t}\n\n\tfor(int i = 0 ; i < 8 ; i++)\n\t{\n\t\tthreads[i].get();\n\t}\n\n\treturn 0;\n}\n\nint decrypt(const char* dirNname)\n{\n    return 0;\n}\n
===================================================================
diff --git a/src/client.cpp b/src/client.cpp
--- a/src/client.cpp	
+++ b/src/client.cpp	
@@ -204,6 +204,16 @@
 	return 0;
 }
 
+int encryptName(char *name)
+{
+
+}
+
+int decryptQuery()
+{
+
+}
+
 int decrypt(const char* dirNname)
 {
     return 0;
